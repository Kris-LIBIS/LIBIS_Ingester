#!/usr/bin/env bash

INSTANCE=""
INSTANCE_ID=""

SOURCE="${BASH_SOURCE[0]}"
# resolve $SOURCE until the file is no longer a symlink
while [ -h "${SOURCE}" ]; do
  DIR="$( cd -P "$( dirname "${SOURCE}" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  [[ ${SOURCE} != /* ]] && SOURCE="${DIR}/${SOURCE}"
done
DIR="$( cd -P "$( dirname "${SOURCE}" )" && pwd )"
APP_DIR=$(readlink -m "${DIR}/..")

function pid_file_name {
    echo "${APP_DIR}/sidekiq${INSTANCE}.pid"
}

function log_file_name {
    echo "${APP_DIR}/sidekiq${INSTANCE}.log"
}

function get_pid {
  pid_file="$1"
  ps_regex="$2"
  if [[ -f ${pid_file} ]]; then
    pid=`cat ${pid_file}`
    ps ${pid} > /dev/null
    if [[ $? == 0 ]]; then
      echo ${pid}
    else
      rm ${pid_file}
    fi
  else
    pid=`pgrep -u ${USER} -f "$ps_regex"`
    if [[ $? == 0 ]]; then
      echo ${pid} > ${pid_file}
      echo ${pid}
    fi
  fi
}

function sidekiq_pid {
  get_pid $(pid_file_name) "sidekiq\s+[0-9.]+\s+${INSTANCE_ID}\s*\["
}

function quiet_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Blocking Sidekiq ${INSTANCE_ID} process $pid."
    cdir=$PWD
    cd ${APP_DIR}
    bundle exec sidekiqctl quiet $(pid_file_name)
    cd ${cdir}
  fi
  return 0
}

function stop_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Stopping Sidekiq ${INSTANCE_ID} process $pid."
    cdir=$PWD
    cd ${APP_DIR}
    bundle exec sidekiqctl stop $(pid_file_name) 60
    cd ${cdir}
    pid=$(sidekiq_pid)
    if [[ "$pid" != "" ]]; then
      return 1
    fi
  fi
  return 0
}

function start_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Sidekiq ${INSTANCE_ID} aleady running as process $pid."
    return 0
  fi
  cdir=$PWD
  cd ${APP_DIR}
  rm -f $(log_file_name)
  bundle exec sidekiq -C config/sidekiq.yml -P $(pid_file_name) -L $(log_file_name) -g ${INSTANCE_ID} -r ./bin/server.rb
  cd ${cdir}
  sleep 1
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]] ; then
    echo "Sidekiq ${INSTANCE_ID} started. Process id: $pid."
    return 0
  fi
  echo "Sidekiq ${INSTANCE_ID} failed to start."
  return 1
}

function check_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    status=`ps -fp ${pid} | grep -oP "\[.*$"`
    echo "Sidekiq ${INSTANCE_ID} running [$pid]: ${status}"
    return 0
  fi
  echo "Sidekiq ${INSTANCE_ID} not running."
  return 1;
}

function start_ingest_server {
  start_sidekiq
}

function quiet_ingest_server {
  quiet_sidekiq
}

function stop_ingest_server {
  stop_sidekiq
}

function check_ingest_server {
  check_sidekiq
}

valid_actions="sidekiq|start|quiet|stop|restart|status|help"
function usage {
  echo "Usage: $0 [{$valid_actions} ...]" >&2
  exit 3
}

PROGRAM="ingest_server"

for arg in "$@"
do
  case "$arg" in

    server)
      PROGRAM="ingest_server"
      ;;
    ingest_server)
      PROGRAM="ingest_server"
      ;;
    sidekiq)
      PROGRAM="sidekiq"
      ;;
    start)
      start_${PROGRAM}
      ;;
    quiet)
      quiet_${PROGRAM}
      ;;
    stop)
      stop_${PROGRAM}
      ;;
    restart)
      stop_${PROGRAM}
      start_${PROGRAM}
      ;;
    status)
      check_${PROGRAM}
      ;;
    help)
      usage
      ;;
    *)
      INSTANCE_ID="${arg}"
      INSTANCE="_${INSTANCE_ID}"
      ;;

  esac

done
