#!/usr/bin/env bash

SOURCE="${BASH_SOURCE[0]}"
# resolve $SOURCE until the file is no longer a symlink
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  [[ ${SOURCE} != /* ]] && SOURCE="$DIR/$SOURCE"
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

APP_DIR=$(readlink -m "$DIR/..")
SK_PID_FILE=${APP_DIR}/sidekiq.pid

REDIS_PID_FILE=$HOME/redis/redis.pid
REDIS_DIR=/opt/redis3/bin

function get_pid {
  pid_file_name=$1
  ps_regex="$2"
  if [[ -f ${pid_file_name} ]]; then
    pid=`cat ${pid_file_name}`
    ps ${pid} > /dev/null
    if [[ $? == 0 ]]; then
      echo ${pid}
    else
      rm ${pid_file_name}
    fi
  else
    pid=`pgrep -u ${USER} -f "$ps_regex"`
    if [[ $? == 0 ]]; then
      echo ${pid} > ${pid_file_name}
      echo ${pid}
    fi
  fi
}

function redis_pid {
  get_pid ${REDIS_PID_FILE} redis-server
}

function sidekiq_pid {
  get_pid ${SK_PID_FILE} "sidekiq.*ingester"
}

function stop_redis {
  pid=$(redis_pid)
  if [[ "$pid" != "" ]]; then
    port=`netstat -tnlp 2>/dev/null | grep "$pid/redis-server" | awk '{gsub(".*:","",$4);print $4}'`
    echo "Stopping Redis server process $pid listening on port $port."
    ${REDIS_DIR}/redis-cli -p ${port} shutdown save
    pid=$(redis_pid)
    if [[ "$pid" != "" ]]; then

      return 1
    fi
  fi
  return 0
}

function stop_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Stopping Sidekiq process $pid."
    cdir=$PWD
    cd ${APP_DIR}
    bundle exec sidekiqctl stop ${SK_PID_FILE}
    cd ${cdir}
    pid=$(sidekiq_pid)
    if [[ "$pid" != "" ]]; then
      return 1
    fi
  fi
  return 0
}

function start_redis {
  pid=$(redis_pid)
  if [[ "$pid" != "" ]]; then
    echo "Redis already running as process $pid."
    return 0;
  fi
  ${REDIS_DIR}/redis-server $HOME/redis/redis.conf
  pid=$(redis_pid)
  if [[ "$pid" != "" ]] ; then
    echo "Redis server started. Process id: $pid."
    return 0
  fi
  echo "Redis server failed to start."
  return 1
}

function start_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Sidekiq aleady running as process $pid."
    return 0
  fi
  cdir=$PWD
  cd ${APP_DIR}
  bundle exec sidekiq -C config/sidekiq.yml -r ./bin/server.rb
  cd ${cdir}
  sleep 1
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]] ; then
    echo "Sidekiq started. Process id: $pid."
    return 0
  fi
  echo "Sidekiq failed to start."
  return 1
}

function check_redis {
  pid=$(redis_pid)
  if [[ "$pid" != "" ]]; then
    echo "Redis running [$pid]."
    return 0;
  fi
  echo "Redis not running."
  return 1;
}

function check_sidekiq {
  pid=$(sidekiq_pid)
  if [[ "$pid" != "" ]]; then
    echo "Sidekiq running [$pid]."
    return 0
  fi
  echo "Sidekiq not running."
  return 1;
}

function start_ingest_server {
  start_redis
  start_sidekiq
}

function stop_ingest_server {
  stop_sidekiq
  stop_redis
}

function check_ingest_server {
  check_redis
  check_sidekiq
}

valid_actions="redis|sidekiq|start|stop|restart|status|help"
function usage {
  echo "Usage: $0 [{$valid_actions} ...]" >&2
  exit 3
}

PROGRAM="ingest_server"

for arg in "$@"
do
  case "$arg" in

    server)
      PROGRAM="ingest_server"
      ;;
    ingest_server)
      PROGRAM="ingest_server"
      ;;
    redis)
      PROGRAM="redis"
      ;;
    sidekiq)
      PROGRAM="sidekiq"
      ;;
    start)
      start_${PROGRAM}
      ;;
    stop)
      stop_${PROGRAM}
      ;;
    restart)
      stop_${PROGRAM}
      start_${PROGRAM}
      ;;
    status)
      check_${PROGRAM}
      ;;
    *)
      usage
      ;;

  esac

done